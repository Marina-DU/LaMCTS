# Generated from IG.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3%")
        buf.write("\u00c1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\3\2\3\2\3\2\3\2\5")
        buf.write("\2\'\n\2\3\2\3\2\3\3\3\3\6\3-\n\3\r\3\16\3.\3\4\3\4\3")
        buf.write("\4\3\4\3\4\3\4\3\4\3\5\3\5\6\5:\n\5\r\5\16\5;\3\6\3\6")
        buf.write("\3\6\3\6\3\6\3\6\6\6D\n\6\r\6\16\6E\3\6\3\6\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7U\n\7\3\7\3\7\3")
        buf.write("\7\7\7Z\n\7\f\7\16\7]\13\7\3\b\3\b\3\b\3\t\3\t\3\t\3\t")
        buf.write("\3\n\3\n\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\13\5\13p\n")
        buf.write("\13\6\13r\n\13\r\13\16\13s\3\13\3\13\3\13\5\13y\n\13\6")
        buf.write("\13{\n\13\r\13\16\13|\3\13\3\13\3\f\3\f\3\f\3\f\3\f\3")
        buf.write("\f\3\f\5\f\u0088\n\f\3\r\3\r\3\r\3\r\3\r\3\r\3\r\5\r\u0091")
        buf.write("\n\r\3\16\3\16\3\16\3\16\3\16\6\16\u0098\n\16\r\16\16")
        buf.write("\16\u0099\3\17\3\17\3\17\3\17\3\17\5\17\u00a1\n\17\6\17")
        buf.write("\u00a3\n\17\r\17\16\17\u00a4\3\17\3\17\3\17\3\17\3\20")
        buf.write("\3\20\3\20\5\20\u00ae\n\20\3\21\3\21\5\21\u00b2\n\21\3")
        buf.write("\21\3\21\3\21\3\21\3\21\5\21\u00b9\n\21\3\21\3\21\3\21")
        buf.write("\3\21\5\21\u00bf\n\21\3\21\2\3\f\22\2\4\6\b\n\f\16\20")
        buf.write("\22\24\26\30\32\34\36 \2\2\2\u00c6\2\"\3\2\2\2\4*\3\2")
        buf.write("\2\2\6\60\3\2\2\2\b\67\3\2\2\2\n=\3\2\2\2\fT\3\2\2\2\16")
        buf.write("^\3\2\2\2\20a\3\2\2\2\22e\3\2\2\2\24j\3\2\2\2\26\u0087")
        buf.write("\3\2\2\2\30\u0090\3\2\2\2\32\u0092\3\2\2\2\34\u009b\3")
        buf.write("\2\2\2\36\u00ad\3\2\2\2 \u00be\3\2\2\2\"#\5\4\3\2#$\5")
        buf.write("\b\5\2$&\5\16\b\2%\'\7\25\2\2&%\3\2\2\2&\'\3\2\2\2\'(")
        buf.write("\3\2\2\2()\7\3\2\2)\3\3\2\2\2*,\7\17\2\2+-\5\6\4\2,+\3")
        buf.write("\2\2\2-.\3\2\2\2.,\3\2\2\2./\3\2\2\2/\5\3\2\2\2\60\61")
        buf.write("\7\32\2\2\61\62\7\35\2\2\62\63\7\33\2\2\63\64\7\4\2\2")
        buf.write("\64\65\7\33\2\2\65\66\7\36\2\2\66\7\3\2\2\2\679\7\20\2")
        buf.write("\28:\5\n\6\298\3\2\2\2:;\3\2\2\2;9\3\2\2\2;<\3\2\2\2<")
        buf.write("\t\3\2\2\2=>\7\32\2\2>?\7\5\2\2?@\5\f\7\2@A\7\6\2\2AC")
        buf.write("\7\"\2\2BD\7\32\2\2CB\3\2\2\2DE\3\2\2\2EC\3\2\2\2EF\3")
        buf.write("\2\2\2FG\3\2\2\2GH\7\36\2\2H\13\3\2\2\2IJ\b\7\1\2JK\7")
        buf.write("\37\2\2KU\5\f\7\7LM\7\7\2\2MN\5\f\7\2NO\7\b\2\2OU\3\2")
        buf.write("\2\2PQ\7\32\2\2QR\7!\2\2RU\7\33\2\2SU\7\32\2\2TI\3\2\2")
        buf.write("\2TL\3\2\2\2TP\3\2\2\2TS\3\2\2\2U[\3\2\2\2VW\f\6\2\2W")
        buf.write("X\7 \2\2XZ\5\f\7\7YV\3\2\2\2Z]\3\2\2\2[Y\3\2\2\2[\\\3")
        buf.write("\2\2\2\\\r\3\2\2\2][\3\2\2\2^_\7\21\2\2_`\5\20\t\2`\17")
        buf.write("\3\2\2\2ab\5\22\n\2bc\5\32\16\2cd\5\24\13\2d\21\3\2\2")
        buf.write("\2ef\7\22\2\2fg\7\t\2\2gh\7\n\2\2hi\7\13\2\2i\23\3\2\2")
        buf.write("\2jk\7\24\2\2kl\7\t\2\2lq\7\n\2\2mo\5\26\f\2np\7\f\2\2")
        buf.write("on\3\2\2\2op\3\2\2\2pr\3\2\2\2qm\3\2\2\2rs\3\2\2\2sq\3")
        buf.write("\2\2\2st\3\2\2\2tu\3\2\2\2uz\7\36\2\2vx\5\30\r\2wy\7\f")
        buf.write("\2\2xw\3\2\2\2xy\3\2\2\2y{\3\2\2\2zv\3\2\2\2{|\3\2\2\2")
        buf.write("|z\3\2\2\2|}\3\2\2\2}~\3\2\2\2~\177\7\13\2\2\177\25\3")
        buf.write("\2\2\2\u0080\u0081\7\r\2\2\u0081\u0082\7\7\2\2\u0082\u0083")
        buf.write("\7\32\2\2\u0083\u0084\7\b\2\2\u0084\u0085\7\35\2\2\u0085")
        buf.write("\u0088\7\33\2\2\u0086\u0088\7\26\2\2\u0087\u0080\3\2\2")
        buf.write("\2\u0087\u0086\3\2\2\2\u0088\27\3\2\2\2\u0089\u008a\7")
        buf.write("\16\2\2\u008a\u008b\7\7\2\2\u008b\u008c\7\32\2\2\u008c")
        buf.write("\u008d\7\b\2\2\u008d\u008e\7\35\2\2\u008e\u0091\7\34\2")
        buf.write("\2\u008f\u0091\7\26\2\2\u0090\u0089\3\2\2\2\u0090\u008f")
        buf.write("\3\2\2\2\u0091\31\3\2\2\2\u0092\u0093\7\23\2\2\u0093\u0097")
        buf.write("\7\t\2\2\u0094\u0095\5\34\17\2\u0095\u0096\7\36\2\2\u0096")
        buf.write("\u0098\3\2\2\2\u0097\u0094\3\2\2\2\u0098\u0099\3\2\2\2")
        buf.write("\u0099\u0097\3\2\2\2\u0099\u009a\3\2\2\2\u009a\33\3\2")
        buf.write("\2\2\u009b\u009c\7\7\2\2\u009c\u009d\7\34\2\2\u009d\u00a2")
        buf.write("\7\f\2\2\u009e\u00a0\5 \21\2\u009f\u00a1\7\27\2\2\u00a0")
        buf.write("\u009f\3\2\2\2\u00a0\u00a1\3\2\2\2\u00a1\u00a3\3\2\2\2")
        buf.write("\u00a2\u009e\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\u00a2\3")
        buf.write("\2\2\2\u00a4\u00a5\3\2\2\2\u00a5\u00a6\3\2\2\2\u00a6\u00a7")
        buf.write("\7\f\2\2\u00a7\u00a8\5\36\20\2\u00a8\u00a9\7\b\2\2\u00a9")
        buf.write("\35\3\2\2\2\u00aa\u00ab\7\32\2\2\u00ab\u00ae\7#\2\2\u00ac")
        buf.write("\u00ae\7\26\2\2\u00ad\u00aa\3\2\2\2\u00ad\u00ac\3\2\2")
        buf.write("\2\u00ae\37\3\2\2\2\u00af\u00b1\7\30\2\2\u00b0\u00b2\7")
        buf.write("#\2\2\u00b1\u00b0\3\2\2\2\u00b1\u00b2\3\2\2\2\u00b2\u00b3")
        buf.write("\3\2\2\2\u00b3\u00b4\7\7\2\2\u00b4\u00b5\7\32\2\2\u00b5")
        buf.write("\u00bf\7\b\2\2\u00b6\u00b8\7\31\2\2\u00b7\u00b9\7#\2\2")
        buf.write("\u00b8\u00b7\3\2\2\2\u00b8\u00b9\3\2\2\2\u00b9\u00ba\3")
        buf.write("\2\2\2\u00ba\u00bb\7\7\2\2\u00bb\u00bc\7\32\2\2\u00bc")
        buf.write("\u00bf\7\b\2\2\u00bd\u00bf\7\26\2\2\u00be\u00af\3\2\2")
        buf.write("\2\u00be\u00b6\3\2\2\2\u00be\u00bd\3\2\2\2\u00bf!\3\2")
        buf.write("\2\2\25&.;ET[osx|\u0087\u0090\u0099\u00a0\u00a4\u00ad")
        buf.write("\u00b1\u00b8\u00be")
        return buf.getvalue()


class IGParser ( Parser ):

    grammarFileName = "IG.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'END'", "'..'", "'['", "']'", "'('", 
                     "')'", "':'", "'{'", "'}'", "','", "'eta'", "'pi'", 
                     "'VAR'", "'REG'", "'HYBRID HOARE'", "'PRE'", "'TRACE'", 
                     "'POST'", "'CYCLIC'", "'True'", "'and'", "'slide'", 
                     "'noslide'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'='", "';'", "'!'", "<INVALID>", "'>='", "'=>'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "KVAR", "KREG", "KHYBRIDHOARE", "KPRE", 
                      "KTRACE", "KPOST", "KCYCLIC", "NOKB", "AND", "SLIDE", 
                      "NOSLIDE", "ID", "NUM", "FLOAT", "EQ", "SEMI", "NEG", 
                      "BOOL_OP", "SEUIL", "CIBLE", "OPER", "WS", "COMMENT" ]

    RULE_prog = 0
    RULE_var_block = 1
    RULE_var_decl = 2
    RULE_reg_block = 3
    RULE_reg_decl = 4
    RULE_reg_expr = 5
    RULE_hybrid_hoare_block = 6
    RULE_hybrid_hoare_decl = 7
    RULE_hybrid_hoare_pre_decl = 8
    RULE_hybrid_hoare_post_decl = 9
    RULE_discrete_condition = 10
    RULE_hybrid_condition = 11
    RULE_hybrid_hoare_trace_decl = 12
    RULE_hybrid_hoare_trace = 13
    RULE_hybrid_hoare_dpa = 14
    RULE_hybrid_hoare_slide = 15

    ruleNames =  [ "prog", "var_block", "var_decl", "reg_block", "reg_decl", 
                   "reg_expr", "hybrid_hoare_block", "hybrid_hoare_decl", 
                   "hybrid_hoare_pre_decl", "hybrid_hoare_post_decl", "discrete_condition", 
                   "hybrid_condition", "hybrid_hoare_trace_decl", "hybrid_hoare_trace", 
                   "hybrid_hoare_dpa", "hybrid_hoare_slide" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    KVAR=13
    KREG=14
    KHYBRIDHOARE=15
    KPRE=16
    KTRACE=17
    KPOST=18
    KCYCLIC=19
    NOKB=20
    AND=21
    SLIDE=22
    NOSLIDE=23
    ID=24
    NUM=25
    FLOAT=26
    EQ=27
    SEMI=28
    NEG=29
    BOOL_OP=30
    SEUIL=31
    CIBLE=32
    OPER=33
    WS=34
    COMMENT=35

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var_block(self):
            return self.getTypedRuleContext(IGParser.Var_blockContext,0)


        def reg_block(self):
            return self.getTypedRuleContext(IGParser.Reg_blockContext,0)


        def hybrid_hoare_block(self):
            return self.getTypedRuleContext(IGParser.Hybrid_hoare_blockContext,0)


        def KCYCLIC(self):
            return self.getToken(IGParser.KCYCLIC, 0)

        def getRuleIndex(self):
            return IGParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProg" ):
                return visitor.visitProg(self)
            else:
                return visitor.visitChildren(self)




    def prog(self):

        localctx = IGParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 32
            self.var_block()
            self.state = 33
            self.reg_block()
            self.state = 34
            self.hybrid_hoare_block()
            self.state = 36
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==IGParser.KCYCLIC:
                self.state = 35
                self.match(IGParser.KCYCLIC)


            self.state = 38
            self.match(IGParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KVAR(self):
            return self.getToken(IGParser.KVAR, 0)

        def var_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IGParser.Var_declContext)
            else:
                return self.getTypedRuleContext(IGParser.Var_declContext,i)


        def getRuleIndex(self):
            return IGParser.RULE_var_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_block" ):
                listener.enterVar_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_block" ):
                listener.exitVar_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_block" ):
                return visitor.visitVar_block(self)
            else:
                return visitor.visitChildren(self)




    def var_block(self):

        localctx = IGParser.Var_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_var_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 40
            self.match(IGParser.KVAR)
            self.state = 42 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 41
                self.var_decl()
                self.state = 44 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==IGParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(IGParser.ID, 0)

        def EQ(self):
            return self.getToken(IGParser.EQ, 0)

        def NUM(self, i:int=None):
            if i is None:
                return self.getTokens(IGParser.NUM)
            else:
                return self.getToken(IGParser.NUM, i)

        def SEMI(self):
            return self.getToken(IGParser.SEMI, 0)

        def getRuleIndex(self):
            return IGParser.RULE_var_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_decl" ):
                listener.enterVar_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_decl" ):
                listener.exitVar_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_decl" ):
                return visitor.visitVar_decl(self)
            else:
                return visitor.visitChildren(self)




    def var_decl(self):

        localctx = IGParser.Var_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_var_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 46
            self.match(IGParser.ID)
            self.state = 47
            self.match(IGParser.EQ)
            self.state = 48
            self.match(IGParser.NUM)
            self.state = 49
            self.match(IGParser.T__1)
            self.state = 50
            self.match(IGParser.NUM)
            self.state = 51
            self.match(IGParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Reg_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KREG(self):
            return self.getToken(IGParser.KREG, 0)

        def reg_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IGParser.Reg_declContext)
            else:
                return self.getTypedRuleContext(IGParser.Reg_declContext,i)


        def getRuleIndex(self):
            return IGParser.RULE_reg_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReg_block" ):
                listener.enterReg_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReg_block" ):
                listener.exitReg_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReg_block" ):
                return visitor.visitReg_block(self)
            else:
                return visitor.visitChildren(self)




    def reg_block(self):

        localctx = IGParser.Reg_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_reg_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53
            self.match(IGParser.KREG)
            self.state = 55 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 54
                self.reg_decl()
                self.state = 57 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==IGParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Reg_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(IGParser.ID)
            else:
                return self.getToken(IGParser.ID, i)

        def reg_expr(self):
            return self.getTypedRuleContext(IGParser.Reg_exprContext,0)


        def CIBLE(self):
            return self.getToken(IGParser.CIBLE, 0)

        def SEMI(self):
            return self.getToken(IGParser.SEMI, 0)

        def getRuleIndex(self):
            return IGParser.RULE_reg_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReg_decl" ):
                listener.enterReg_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReg_decl" ):
                listener.exitReg_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReg_decl" ):
                return visitor.visitReg_decl(self)
            else:
                return visitor.visitChildren(self)




    def reg_decl(self):

        localctx = IGParser.Reg_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_reg_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 59
            self.match(IGParser.ID)
            self.state = 60
            self.match(IGParser.T__2)
            self.state = 61
            self.reg_expr(0)
            self.state = 62
            self.match(IGParser.T__3)
            self.state = 63
            self.match(IGParser.CIBLE)
            self.state = 65 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 64
                self.match(IGParser.ID)
                self.state = 67 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==IGParser.ID):
                    break

            self.state = 69
            self.match(IGParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Reg_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return IGParser.RULE_reg_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Expr_negContext(Reg_exprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IGParser.Reg_exprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NEG(self):
            return self.getToken(IGParser.NEG, 0)
        def reg_expr(self):
            return self.getTypedRuleContext(IGParser.Reg_exprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_neg" ):
                listener.enterExpr_neg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_neg" ):
                listener.exitExpr_neg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_neg" ):
                return visitor.visitExpr_neg(self)
            else:
                return visitor.visitChildren(self)


    class Expr_bool_opContext(Reg_exprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IGParser.Reg_exprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def reg_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IGParser.Reg_exprContext)
            else:
                return self.getTypedRuleContext(IGParser.Reg_exprContext,i)

        def BOOL_OP(self):
            return self.getToken(IGParser.BOOL_OP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_bool_op" ):
                listener.enterExpr_bool_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_bool_op" ):
                listener.exitExpr_bool_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_bool_op" ):
                return visitor.visitExpr_bool_op(self)
            else:
                return visitor.visitChildren(self)


    class Expr_bracketsContext(Reg_exprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IGParser.Reg_exprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def reg_expr(self):
            return self.getTypedRuleContext(IGParser.Reg_exprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_brackets" ):
                listener.enterExpr_brackets(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_brackets" ):
                listener.exitExpr_brackets(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_brackets" ):
                return visitor.visitExpr_brackets(self)
            else:
                return visitor.visitChildren(self)


    class Expr_atomeContext(Reg_exprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IGParser.Reg_exprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(IGParser.ID, 0)
        def SEUIL(self):
            return self.getToken(IGParser.SEUIL, 0)
        def NUM(self):
            return self.getToken(IGParser.NUM, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_atome" ):
                listener.enterExpr_atome(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_atome" ):
                listener.exitExpr_atome(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_atome" ):
                return visitor.visitExpr_atome(self)
            else:
                return visitor.visitChildren(self)


    class Expr_mux_nameContext(Reg_exprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a IGParser.Reg_exprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(IGParser.ID, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_mux_name" ):
                listener.enterExpr_mux_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_mux_name" ):
                listener.exitExpr_mux_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_mux_name" ):
                return visitor.visitExpr_mux_name(self)
            else:
                return visitor.visitChildren(self)



    def reg_expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = IGParser.Reg_exprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 10
        self.enterRecursionRule(localctx, 10, self.RULE_reg_expr, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                localctx = IGParser.Expr_negContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 72
                self.match(IGParser.NEG)
                self.state = 73
                self.reg_expr(5)
                pass

            elif la_ == 2:
                localctx = IGParser.Expr_bracketsContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 74
                self.match(IGParser.T__4)
                self.state = 75
                self.reg_expr(0)
                self.state = 76
                self.match(IGParser.T__5)
                pass

            elif la_ == 3:
                localctx = IGParser.Expr_atomeContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 78
                self.match(IGParser.ID)
                self.state = 79
                self.match(IGParser.SEUIL)
                self.state = 80
                self.match(IGParser.NUM)
                pass

            elif la_ == 4:
                localctx = IGParser.Expr_mux_nameContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 81
                self.match(IGParser.ID)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 89
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = IGParser.Expr_bool_opContext(self, IGParser.Reg_exprContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_reg_expr)
                    self.state = 84
                    if not self.precpred(self._ctx, 4):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                    self.state = 85
                    self.match(IGParser.BOOL_OP)
                    self.state = 86
                    self.reg_expr(5) 
                self.state = 91
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Hybrid_hoare_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KHYBRIDHOARE(self):
            return self.getToken(IGParser.KHYBRIDHOARE, 0)

        def hybrid_hoare_decl(self):
            return self.getTypedRuleContext(IGParser.Hybrid_hoare_declContext,0)


        def getRuleIndex(self):
            return IGParser.RULE_hybrid_hoare_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHybrid_hoare_block" ):
                listener.enterHybrid_hoare_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHybrid_hoare_block" ):
                listener.exitHybrid_hoare_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHybrid_hoare_block" ):
                return visitor.visitHybrid_hoare_block(self)
            else:
                return visitor.visitChildren(self)




    def hybrid_hoare_block(self):

        localctx = IGParser.Hybrid_hoare_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_hybrid_hoare_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92
            self.match(IGParser.KHYBRIDHOARE)
            self.state = 93
            self.hybrid_hoare_decl()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Hybrid_hoare_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def hybrid_hoare_pre_decl(self):
            return self.getTypedRuleContext(IGParser.Hybrid_hoare_pre_declContext,0)


        def hybrid_hoare_trace_decl(self):
            return self.getTypedRuleContext(IGParser.Hybrid_hoare_trace_declContext,0)


        def hybrid_hoare_post_decl(self):
            return self.getTypedRuleContext(IGParser.Hybrid_hoare_post_declContext,0)


        def getRuleIndex(self):
            return IGParser.RULE_hybrid_hoare_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHybrid_hoare_decl" ):
                listener.enterHybrid_hoare_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHybrid_hoare_decl" ):
                listener.exitHybrid_hoare_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHybrid_hoare_decl" ):
                return visitor.visitHybrid_hoare_decl(self)
            else:
                return visitor.visitChildren(self)




    def hybrid_hoare_decl(self):

        localctx = IGParser.Hybrid_hoare_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_hybrid_hoare_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            self.hybrid_hoare_pre_decl()
            self.state = 96
            self.hybrid_hoare_trace_decl()
            self.state = 97
            self.hybrid_hoare_post_decl()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Hybrid_hoare_pre_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KPRE(self):
            return self.getToken(IGParser.KPRE, 0)

        def getRuleIndex(self):
            return IGParser.RULE_hybrid_hoare_pre_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHybrid_hoare_pre_decl" ):
                listener.enterHybrid_hoare_pre_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHybrid_hoare_pre_decl" ):
                listener.exitHybrid_hoare_pre_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHybrid_hoare_pre_decl" ):
                return visitor.visitHybrid_hoare_pre_decl(self)
            else:
                return visitor.visitChildren(self)




    def hybrid_hoare_pre_decl(self):

        localctx = IGParser.Hybrid_hoare_pre_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_hybrid_hoare_pre_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.match(IGParser.KPRE)
            self.state = 100
            self.match(IGParser.T__6)
            self.state = 101
            self.match(IGParser.T__7)
            self.state = 102
            self.match(IGParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Hybrid_hoare_post_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KPOST(self):
            return self.getToken(IGParser.KPOST, 0)

        def SEMI(self):
            return self.getToken(IGParser.SEMI, 0)

        def discrete_condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IGParser.Discrete_conditionContext)
            else:
                return self.getTypedRuleContext(IGParser.Discrete_conditionContext,i)


        def hybrid_condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IGParser.Hybrid_conditionContext)
            else:
                return self.getTypedRuleContext(IGParser.Hybrid_conditionContext,i)


        def getRuleIndex(self):
            return IGParser.RULE_hybrid_hoare_post_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHybrid_hoare_post_decl" ):
                listener.enterHybrid_hoare_post_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHybrid_hoare_post_decl" ):
                listener.exitHybrid_hoare_post_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHybrid_hoare_post_decl" ):
                return visitor.visitHybrid_hoare_post_decl(self)
            else:
                return visitor.visitChildren(self)




    def hybrid_hoare_post_decl(self):

        localctx = IGParser.Hybrid_hoare_post_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_hybrid_hoare_post_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            self.match(IGParser.KPOST)
            self.state = 105
            self.match(IGParser.T__6)
            self.state = 106
            self.match(IGParser.T__7)
            self.state = 111 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 107
                self.discrete_condition()
                self.state = 109
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IGParser.T__9:
                    self.state = 108
                    self.match(IGParser.T__9)


                self.state = 113 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==IGParser.T__10 or _la==IGParser.NOKB):
                    break

            self.state = 115
            self.match(IGParser.SEMI)
            self.state = 120 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 116
                self.hybrid_condition()
                self.state = 118
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IGParser.T__9:
                    self.state = 117
                    self.match(IGParser.T__9)


                self.state = 122 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==IGParser.T__11 or _la==IGParser.NOKB):
                    break

            self.state = 124
            self.match(IGParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Discrete_conditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(IGParser.ID, 0)

        def EQ(self):
            return self.getToken(IGParser.EQ, 0)

        def NUM(self):
            return self.getToken(IGParser.NUM, 0)

        def NOKB(self):
            return self.getToken(IGParser.NOKB, 0)

        def getRuleIndex(self):
            return IGParser.RULE_discrete_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiscrete_condition" ):
                listener.enterDiscrete_condition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiscrete_condition" ):
                listener.exitDiscrete_condition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDiscrete_condition" ):
                return visitor.visitDiscrete_condition(self)
            else:
                return visitor.visitChildren(self)




    def discrete_condition(self):

        localctx = IGParser.Discrete_conditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_discrete_condition)
        try:
            self.state = 133
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IGParser.T__10]:
                self.enterOuterAlt(localctx, 1)
                self.state = 126
                self.match(IGParser.T__10)
                self.state = 127
                self.match(IGParser.T__4)
                self.state = 128
                self.match(IGParser.ID)
                self.state = 129
                self.match(IGParser.T__5)
                self.state = 130
                self.match(IGParser.EQ)
                self.state = 131
                self.match(IGParser.NUM)
                pass
            elif token in [IGParser.NOKB]:
                self.enterOuterAlt(localctx, 2)
                self.state = 132
                self.match(IGParser.NOKB)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Hybrid_conditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(IGParser.ID, 0)

        def EQ(self):
            return self.getToken(IGParser.EQ, 0)

        def FLOAT(self):
            return self.getToken(IGParser.FLOAT, 0)

        def NOKB(self):
            return self.getToken(IGParser.NOKB, 0)

        def getRuleIndex(self):
            return IGParser.RULE_hybrid_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHybrid_condition" ):
                listener.enterHybrid_condition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHybrid_condition" ):
                listener.exitHybrid_condition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHybrid_condition" ):
                return visitor.visitHybrid_condition(self)
            else:
                return visitor.visitChildren(self)




    def hybrid_condition(self):

        localctx = IGParser.Hybrid_conditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_hybrid_condition)
        try:
            self.state = 142
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IGParser.T__11]:
                self.enterOuterAlt(localctx, 1)
                self.state = 135
                self.match(IGParser.T__11)
                self.state = 136
                self.match(IGParser.T__4)
                self.state = 137
                self.match(IGParser.ID)
                self.state = 138
                self.match(IGParser.T__5)
                self.state = 139
                self.match(IGParser.EQ)
                self.state = 140
                self.match(IGParser.FLOAT)
                pass
            elif token in [IGParser.NOKB]:
                self.enterOuterAlt(localctx, 2)
                self.state = 141
                self.match(IGParser.NOKB)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Hybrid_hoare_trace_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KTRACE(self):
            return self.getToken(IGParser.KTRACE, 0)

        def hybrid_hoare_trace(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IGParser.Hybrid_hoare_traceContext)
            else:
                return self.getTypedRuleContext(IGParser.Hybrid_hoare_traceContext,i)


        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(IGParser.SEMI)
            else:
                return self.getToken(IGParser.SEMI, i)

        def getRuleIndex(self):
            return IGParser.RULE_hybrid_hoare_trace_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHybrid_hoare_trace_decl" ):
                listener.enterHybrid_hoare_trace_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHybrid_hoare_trace_decl" ):
                listener.exitHybrid_hoare_trace_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHybrid_hoare_trace_decl" ):
                return visitor.visitHybrid_hoare_trace_decl(self)
            else:
                return visitor.visitChildren(self)




    def hybrid_hoare_trace_decl(self):

        localctx = IGParser.Hybrid_hoare_trace_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_hybrid_hoare_trace_decl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 144
            self.match(IGParser.KTRACE)
            self.state = 145
            self.match(IGParser.T__6)
            self.state = 149 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 146
                self.hybrid_hoare_trace()
                self.state = 147
                self.match(IGParser.SEMI)
                self.state = 151 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==IGParser.T__4):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Hybrid_hoare_traceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(IGParser.FLOAT, 0)

        def hybrid_hoare_dpa(self):
            return self.getTypedRuleContext(IGParser.Hybrid_hoare_dpaContext,0)


        def hybrid_hoare_slide(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(IGParser.Hybrid_hoare_slideContext)
            else:
                return self.getTypedRuleContext(IGParser.Hybrid_hoare_slideContext,i)


        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(IGParser.AND)
            else:
                return self.getToken(IGParser.AND, i)

        def getRuleIndex(self):
            return IGParser.RULE_hybrid_hoare_trace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHybrid_hoare_trace" ):
                listener.enterHybrid_hoare_trace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHybrid_hoare_trace" ):
                listener.exitHybrid_hoare_trace(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHybrid_hoare_trace" ):
                return visitor.visitHybrid_hoare_trace(self)
            else:
                return visitor.visitChildren(self)




    def hybrid_hoare_trace(self):

        localctx = IGParser.Hybrid_hoare_traceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_hybrid_hoare_trace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 153
            self.match(IGParser.T__4)
            self.state = 154
            self.match(IGParser.FLOAT)
            self.state = 155
            self.match(IGParser.T__9)
            self.state = 160 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 156
                self.hybrid_hoare_slide()
                self.state = 158
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IGParser.AND:
                    self.state = 157
                    self.match(IGParser.AND)


                self.state = 162 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << IGParser.NOKB) | (1 << IGParser.SLIDE) | (1 << IGParser.NOSLIDE))) != 0)):
                    break

            self.state = 164
            self.match(IGParser.T__9)
            self.state = 165
            self.hybrid_hoare_dpa()
            self.state = 166
            self.match(IGParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Hybrid_hoare_dpaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(IGParser.ID, 0)

        def OPER(self):
            return self.getToken(IGParser.OPER, 0)

        def NOKB(self):
            return self.getToken(IGParser.NOKB, 0)

        def getRuleIndex(self):
            return IGParser.RULE_hybrid_hoare_dpa

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHybrid_hoare_dpa" ):
                listener.enterHybrid_hoare_dpa(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHybrid_hoare_dpa" ):
                listener.exitHybrid_hoare_dpa(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHybrid_hoare_dpa" ):
                return visitor.visitHybrid_hoare_dpa(self)
            else:
                return visitor.visitChildren(self)




    def hybrid_hoare_dpa(self):

        localctx = IGParser.Hybrid_hoare_dpaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_hybrid_hoare_dpa)
        try:
            self.state = 171
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IGParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 168
                self.match(IGParser.ID)
                self.state = 169
                self.match(IGParser.OPER)
                pass
            elif token in [IGParser.NOKB]:
                self.enterOuterAlt(localctx, 2)
                self.state = 170
                self.match(IGParser.NOKB)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Hybrid_hoare_slideContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLIDE(self):
            return self.getToken(IGParser.SLIDE, 0)

        def ID(self):
            return self.getToken(IGParser.ID, 0)

        def OPER(self):
            return self.getToken(IGParser.OPER, 0)

        def NOSLIDE(self):
            return self.getToken(IGParser.NOSLIDE, 0)

        def NOKB(self):
            return self.getToken(IGParser.NOKB, 0)

        def getRuleIndex(self):
            return IGParser.RULE_hybrid_hoare_slide

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHybrid_hoare_slide" ):
                listener.enterHybrid_hoare_slide(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHybrid_hoare_slide" ):
                listener.exitHybrid_hoare_slide(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHybrid_hoare_slide" ):
                return visitor.visitHybrid_hoare_slide(self)
            else:
                return visitor.visitChildren(self)




    def hybrid_hoare_slide(self):

        localctx = IGParser.Hybrid_hoare_slideContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_hybrid_hoare_slide)
        self._la = 0 # Token type
        try:
            self.state = 188
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [IGParser.SLIDE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 173
                self.match(IGParser.SLIDE)
                self.state = 175
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IGParser.OPER:
                    self.state = 174
                    self.match(IGParser.OPER)


                self.state = 177
                self.match(IGParser.T__4)
                self.state = 178
                self.match(IGParser.ID)
                self.state = 179
                self.match(IGParser.T__5)
                pass
            elif token in [IGParser.NOSLIDE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 180
                self.match(IGParser.NOSLIDE)
                self.state = 182
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==IGParser.OPER:
                    self.state = 181
                    self.match(IGParser.OPER)


                self.state = 184
                self.match(IGParser.T__4)
                self.state = 185
                self.match(IGParser.ID)
                self.state = 186
                self.match(IGParser.T__5)
                pass
            elif token in [IGParser.NOKB]:
                self.enterOuterAlt(localctx, 3)
                self.state = 187
                self.match(IGParser.NOKB)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[5] = self.reg_expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def reg_expr_sempred(self, localctx:Reg_exprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 4)
         




